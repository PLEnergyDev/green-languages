name: division-loop
language: rust
description: |
    Consider for a given M the problem of finding the least integer n such that 1/1 + 1/2 + 1/3 + ... + 1/n >= M.
    For M = 20 the answer is n = 272400600 and the loop performs that many iterations.
    Each iteration involves a floating-point comparison, a floating-point division and a floating-point addition, as well as an integer increment.
code: |
    #[link(name = "measurements")]
    unsafe extern "C" {
        fn start_measurement() -> bool;
        fn end_measurement();
    }

    fn run_benchmark(args: &[String]) {
        let m: i32 = args.get(0)
            .expect("Missing argument")
            .parse()
            .expect("Invalid integer");
        let mut sum = 0.0;
        let mut n = 0;
        while sum < m as f64 {
            n += 1;
            sum += 1.0 / n as f64;
        }
        println!("{}", n);
    }

    fn main() {
        let args: Vec<String> = std::env::args().skip(1).collect();
        loop {
            unsafe {
                if !start_measurement() {
                    break;
                }
            }
            run_benchmark(&args);
            unsafe {
                end_measurement();
            }
        }
    }
arguments: [20]
compile_options: [--release]
expected_stdout: !!binary |
    MjcyNDAwNjAwCg==
---
name: release
measurement_mode: internal
---
name: release
measurement_mode: external
